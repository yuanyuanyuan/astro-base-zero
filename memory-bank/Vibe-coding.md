---
created: 2025-07-09T15:34
updated: 2025-07-10T12:47
---

# 《Vibe Coding 权威实践手册》--3.0


## 序章：思维奠基 —— 在编码前成为“架构师”

在触摸键盘之前，我们必须完成一次彻底的思维转变。Vibe Coding 的灵魂，是角色的重塑。
1. 核心角色转变：从“编码员”到“项目总监”
  - 你不再是那个亲手砌砖的工匠，而是成为了设计整座大教堂的总建筑师。你的职责是规划、设计和监督。
  - 这意味着，你需要将100%的精力聚焦于设计和保障那20%的核心架构（地基与承重柱）。
  - 当你能熟练地执行整个工作流时，你会进入一种行云流水的“心流”状态，并收获前所未有的掌控感、大局观和节奏感。
2. 核心工作隐喻：AI 是你的高效施工队
  - AI 是你的施工队，他们拥有无数个超人，可以在一秒钟内砌好一万块砖，但他们完全没有审美和思考能力 。
  - 如果你对他们说：“给我盖个漂亮的教堂”，他们会把砖块堆成一团糟。
  - 如果你给他们一份精确到每一块砖的位置、每一个窗户的尺寸的蓝图，他们就能在一夜之间为你建起一座完美的圣母大院 。
  - 因此，Vibe Coding 的核心产出并非代码，而是那份极致清晰、无歧义的“蓝图”——即你的各种规划文档。
3. 核心工程哲学：拥抱 80/20 法则
  - 我们不追求一次性做出100%完美的产品。在产品初期，花费80%的精力去完善那额外的20%价值，是一笔糟糕的投资。
  - 我们的目标是，先用20%的力气拿到80分的成果，这已经“超级好了”。
  - 识别出项目中那“关键的20%”——通常是核心数据结构和模块间的契约——并投入100%的精力用最严谨的方式确保其正确。
  - 对于剩下那80%的“血肉”（如UI组件），则可以大胆利用AI，快速迭代，实现“足够好”即可。这是一种主动的、健康的“技术债”管理策略。
4. 每一个任务或者每一步或者每一个阶段完成后都需要做review：
   - 授权AI 进行大胆提问，在你发送的指令末尾，可以加上一句：“Think as long as needed to get this right， I am not in a hurry。 What matters is that you follow precisely what I ask you and execute it perfectly. Ask me questions if I am not precise enough.”  这句话赋予了 AI “反问”的权利，当你的指令有歧义时，它会主动寻求澄清，而不是基于错误的猜测去执行，从而极大减少了返工的概率。
   - 把一个功能点同时丢给多个不同的[专业的AI大模型]。看看它们各自提供的拆解策略。它们会像多个免费顾问一样，给你提供不同的思路，然后你结合自己的经验进行review，就能整理出最全面、最合理的子任务列表。
   - 在编写 implementation-plan.md 之前，构建一个完整的、层级分明的任务树，这个任务树的顶端是最终产品，下面是主要功能模块，再往下是子功能，最后才是具体的、可执行的原子任务。基于这个任务树进行review，这能确保你从第一行代码开始，就拥有了上帝视角的“大局观” 
   - 每当你或 AI 添加了一个新文件或服务，你就必须立刻去 architecture.md 中记录下它的用途和职责。


## 第一阶段：地基工程 —— 项目的规划与环境设定

这是整个流程的起点，地基的质量决定了建筑最终的高度。


### 【任务一】绘制蓝图：定义产品需求 (PRD/GDD)
**目标：** 将项目想法转化为清晰、聚焦本质的产品需求蓝图。
**核心原则：** **穿透用户表面表达，洞察其未明说的决策动因与真实目标 (JTBD)**。

**步骤与要求：**

1.  **需求洞察与穿透 (核心新增)：**
    *   **超越表面需求：** 明确认识到用户表达的需求（如“关注性能”）往往是表面的、模式化的。**核心任务在于识别其未明说的、真正驱动行为的“真需求”**（如“A车座椅更贴合腰部”）。
    *   **方法论：差异比较法：** 在需求收集和分析阶段，**强制使用“差异比较法”**：
        *   要求用户或分析用户行为时，**对比其选择与放弃的选项**（如“为什么最终选了A而不是B/C？”）。
        *   **聚焦具体差异点**（如“A vs. B 的区别是什么？哪个点最终让你做了决定？”）。
        *   此方法旨在**打破用户的模式化表达框架**，揭示隐藏的决策动因和痛点/爽点。
    *   **工具协同：场景化 + JTBD：**
        *   **场景化是“探针”：** 在需求模糊期（早期），优先使用**具体、生动的用户场景**（Who, When, Where, What, Why, How）作为破局工具。场景能具象化需求，暴露真实问题和机会。*例如：“通勤高峰期，在拥挤地铁上（场景），用户需要快速单手操作手机完成支付（需求）”。*
        *   **JTBD是“罗盘”：** 在目标共识期，使用**Jobs-to-be-Done (JTBD)** 框架锚定终极目标。JTBD 描述用户渴望达成的、**稳定且与具体方案无关的终极状态或目标**。
        *   **协同关系：** `场景化` 帮助**穿透需求迷雾**，发现具体问题和线索；`JTBD` 则基于这些发现，**提炼出稳定、本质的目标**，为后续设计提供清晰方向。两者结合实现“既见树木（具体场景），又见森林（终极目标）”。

2.  **定义核心“待完成的工作 (JTBD)”：**
    *   基于需求洞察（尤其是差异比较法和场景化分析的结果），**清晰定义 1-N 个核心 JTBD**。
    *   **JTBD 描述：** 聚焦用户渴望达成的**终极目标或状态**，**避免提及具体功能或解决方案**。
        *   *好例子 (稳定、本质)：* “当我需要深度专注时，帮助我毫不费力地进入和维持心流状态，并在恰当的时候用一种无干扰的方式提醒我休息。” (未提计时器、震动等)
        *   *差例子 (具体方案)：* “用户需要一个 25 分钟的番茄钟计时器。”

3.  **设计用户故事：**
    *   用户故事是**为实现 JTBD 而设计的具体战术或功能**。它们是达成终极目标的手段。
    *   **来源与验证：** 用户故事应**直接服务于定义的 JTBD**，并能在**具体用户场景**中得到验证。
    *   **写作要求：** 采用标准格式 `As a [用户角色], I want to [动作], so that [达成 JTBD 相关的价值/目标]`。**强化`so that`部分与 JTBD 的关联**。
    *   **优先级排序 (MoSCoW 法则)：**
        *   **`Must`**: 绝对核心，没有它 JTBD 无法达成或产品价值崩溃。
        *   **`Should`**: 重要但不是核心，对达成 JTBD 有显著提升。
        *   **`Could`**: 期望功能，对达成 JTBD 有辅助作用或提升体验，可延期。
        *   **`Won't`**: 本次明确不做（有助于管理范围蔓延）。
    *   **应用洞察：** 在编写用户故事时，**回顾差异比较法的发现**，确保故事解决了那些被识别出的*真需求*和*关键差异点*。
    *   **反用户故事 (可选但推荐)：** 针对关键场景，可考虑“反用户故事”以明确边界（如 `As a user, I do NOT want to be interrupted by loud alarms when in a meeting`）。

4.  **定义数据契约 (面向契约开发)：**
    *   在 PRD 中**明确定义关键接口、数据结构或状态模型（数据契约）**。
    *   **目的：** 清晰约定数据格式、类型和含义，确保前后端、模块间协作顺畅，减少歧义和返工。让 AI 开发基于契约而非猜测。
    *   **形式：** 可使用 TypeScript 接口、JSON Schema、伪代码或简洁描述。
        *   *例子：* `TimerSessionData { sessionId: string, startTime: ISO8601, targetDuration: number (seconds), status: 'active' | 'paused' | 'completed' | 'cancelled' }`
    *   **实践：** 可先让 AI 生成初步的 OpenAPI 规范或数据模型，再基于此细化契约并开发组件。

5.  **利用专业 AI 大模型 & 人工决策：**
    *   将你的项目想法、核心洞察（差异点、场景、初步 JTBD 想法）交给 **[专业的 AI 大模型]**，让它为你生成一份 **PRD/GDD 草稿（Markdown 格式）**。
    *   **你必须亲自审查和修改这份文档：**
        *   **严格审视需求洞察：** AI 生成的差异分析是否深刻？场景是否真实？JTBD 是否抓住了本质？
        *   **验证一致性：** 确保用户故事有效支撑 JTBD，数据契约合理。
        *   **最终决策权：** AI 产出只是高效起点，你的决策（基于业务目标、用户真需求和资源）才是最终版本。**AI 是助手，你是决策者。**

**产出物：** 一份经过你深度审查、修改、认可的 `产品需求文档.md` 或 `游戏设计文档.md`，清晰包含：
*   通过**差异比较法**和**场景化**挖掘出的核心洞察。
*   基于洞察定义的、本质的 **JTBD**。
*   服务于 JTBD、在场景中验证的、带 **MoSCoW 优先级**的**用户故事列表**。
*   关键的**数据契约/接口定义**。
*   (可选) 关键用户场景描述。


  
### 【任务二】选择建材：决策技术栈 (Tech Stack)
  - 要求[专业的AI大模型]为你的项目推荐技术栈，并将结果保存为 tech-stack.md 。
    - 例如在tech-stack.md中强制包含版本锁死（如 Node.js v20, React v18），确保 AI 不会推荐过时或不兼容的版本。
  - 关键指令：不要只问“推荐一个技术栈”，而是要“挑战”AI，让它“提出尽可能最简单且最健壮的技术栈 (propose the simplest yet most robust stack possible)” 。这会迫使 AI 进行权衡，而不是给出最“流行”的答案。
  - 运用三层滤网决策：从 PRD 到技术栈，是一个“需求解读与决策权衡”的过程。你可以用三层滤网来分析 PRD，为 AI 提供更丰富的决策依据：
    1. 功能性需求：它需要“做什么”？（例如：需要实时交互吗？需要复杂后台任务吗？）
    2. 非功能性需求：它需要“做得多好”？（例如：用户规模是1百人还是1百万人？性能要求多高？安全性要求多高？）
    3. 未来与愿景：它“将要去向何方”？（例如：V2 版本是否计划加入用户系统？这会影响当下的技术选型，是在“短期便捷性”与“长期扩展性”之间做权衡）。
  - 当你用这三层滤网分析完你的 PRD 后，你就可以给 AI 一个信息量极大的、包含你深度思考的指令，而不是一个简单的请求。
      糟糕的指令：“这是我的 PRD，给我一个技术栈。”
      优秀的指令：“你好，请根据以下产品需求文档（PRD）和我的约束条件，为我推荐一个技术栈。[在这里粘贴你的整个 PRD 内容]，约束与决策依据：
        1. 核心原则：技术栈必须是“尽可能最简单且最健壮的” 。我们优先考虑长期稳定性和低维护成本。
        2. 规模预期：V1 版本的预期用户量在 1 万人以内，但请考虑未来扩展到 10 万用户的可能性。
        3. 关键功能：PRD 中提到的 例如：“实时通知” 是核心功能，技术选型必须能完美支持。
        4. 未来愿景：虽然 V1 是纯前端应用，但 V2 计划加入用户账户和数据统计功能，请在选型时考虑到这一点，推荐一个易于扩展的方案。
      请详细解释你推荐的每一个技术的理由，并说明它们是如何满足上述这些约束条件的。 ”

  - 这样，你就能得到一个经过深思熟虑的、真正符合你项目需求的技术栈，而不是一个随便的推荐列表。


<!-- ### 【任务三】搭建指挥中心：配置工作环境
  - 创建记忆银行：在项目根目录创建一个 memory-bank 文件夹，将前面生成的 PRD.md 和 tech-stack.md 等核心文档放入其中。这里是项目唯一的、不容置疑的真理来源 。
  - 生成规则：在 Cursor 中，使用 `/Generate Cursor Rules` 命令，基于你的核心文档自动生成规则文件 (.mdc) 。
  - 配置代码片段：在 Cursor (或 VS Code) 中，通过 Configure User Snippets 将常用的指令（如 vstep, vfix）配置成代码片段，实现“战术热键”功能，极大提升指令下达速度 。
  - 手动强化规则：AI 自动生成的规则只是基础，你必须手动审查并强化它。最重要的修改就是创建 
  - "Always" 规则。
    - 创建 "Always" 规则：将读取核心文档（如tech-stack.md, architecture.md, PRD.md）的规则设置为“始终 (always)”触发。这会强制 AI 在执行任何操作前，都必须以这些“法律文件”作为首要信息源，从而避免“失忆”或偏离轨道。
    - 将核心原则写入规则：将你在技术栈和 PRD 中定义的核心约束（如“必须使用原生 JS，禁止用框架”、“所有代码必须模块化，禁止单体文件”）明确地翻译成规则条文。这样你就拥有了一个“自带说明书和行为准则的 AI”。 -->

### 【任务三】制定施工蓝图：编写实施计划 (Implementation Plan)

-  **核心定位**：这份计划是您作为“架构师”用来指挥“AI 施工队”的蓝图，因此，里面只应包含清晰、具体的指令，而不应包含任何代码。
-  **准备工作**：将您准备好的所有核心文档（PRD/GDD, Tech Stack,）内容，全部交给您的“规划伙伴”（如[专业的AI大模型]）。
-  **群策群力 (AI 顾问团)**：在您亲自制定最终计划前，可以先将一个核心功能点同时交给多个不同的AI大语言模型（如 [专业的AI大模型]），看看它们各自提供的拆解策略。它们会像免费的顾问团一样，为您提供不同思路，然后您再结合自身经验，整理出最全面的任务列表。
-  **构建任务树 (大局观)**：在动笔编写 `implementation-plan.md` 之前，先在脑中或白板上构建一个完整的、层级分明的任务树。这个树的顶端是最终产品，下面是主要功能模块，再往下是子功能，最后才是具体的、可执行的原子任务。这能确保您从第一行代码开始，就拥有上帝视角的“大局观”。
-  **极致的“原子化”拆解**：任务必须被拆分到“几乎不可能被误解”的原子粒度。
    -  **“试金石”标准**：一个简单的判断标准是，这个子任务的指令是否清晰、具体到[专业的AI大模型]可以一次性完成，而不需要它自己去总结和提炼？如果您感觉任务描述太长，需要AI二次解读，那么它就太大了。
    -  **最终目的**：最高质量的产出，并非来自一个无所不能的“超级指令”，而是源于您将一个复杂问题拆解到极致的耐心和洞察力。

-  **每一步都必须包含“验证标准”**：这是绝对的关键，是Vibe Coding工作流的“守门员”。
    -  **客观标准**：每个步骤后面，都必须包含一个简单的、客观的测试方法，用于验证该步骤是否已正确完成。
    -  **赋予意义**：这为您自己和AI都提供了“完成”的明确定义，确保每一个微小的功能增量都符合预期。

-   **运用 TDD/BDD 风格（大师级实践）**：为了追求极致的工程质量，您可以升级您的计划编写方式。
    -  用BDD的 **Given-When-Then** (假如-当-那么) 格式来描述测试标准。这能以用户的行为视角来思考功能，并为编写自动化测试提供无歧义的、机器也能理解的规范。

-  **模块化计划**：如果一个项目过于庞大，不要试图创建一个包罗万象的 `implementation-plan.md`。应该为每一个主要功能或特性，创建一个独立的 `feature-implementation.md` 文件，并增量实现。

-   **最终保险：“起飞前检查” (Pre-flight Check)**
    -  **核心操作**：在真正开始编码前，将新鲜出炉的 `implementation-plan.md` 交给将要执行编码的AI（如 Cursor 中的 Claude），然后向它提问：“请阅读 memory-bank 里的所有文档，这份实施计划对你来说 100% 清晰吗？你有哪些问题可以帮助你更精确地理解任务？” 。
    -  **价值所在**：AI通常会提出若干问题来澄清模糊之处。根据它的提问，您再反过来优化您的施工计划，使其更完美。这个看似多余的步骤，是成本最低的“纠错机会”，能避免因误解造成的重大返工。


## 第二阶段：核心施工 —— 指挥 AI 的心跳节拍

这是 Vibe Coding 的心跳，一个从想法到现实的、周而复始的循环。当你熟练之后，就会进入一种行云流水的“心流”状态。

Vibe Coding 核心工作流：七步心跳法：

### 【第一步】澄清 (Clarify) - “起飞前检查”
  - 在正式下达第一个编码指令前，先对你的“施工蓝图”进行一次“保险检查”。
  - 向执行编码的 AI（如 Cursor 中的 Claude）提问：“请阅读 /memory-bank 里的所有文档，特别是 implementation-plan.md。这个计划对你来说 100% 清晰吗？你有哪些问题可以帮助你更精确地理解任务？”
  - 让文档“活起来”：AI 通常会提出若干问题来澄清模糊之处。你要根据它的提问，反过来优化你的 implementation-plan.md，让它变得真正完美。这个看似多余的步骤，是成本最低的“纠错机会”。

### 【第二步】指令 (Prompt) - “下达施工命令”
  - 使用你之前配置好的代码片段（Snippet），例如输入 vstep 并按 Tab，快速生成标准指令。
  - 指令的核心内容是：“阅读 /memory-bank 获取最新上下文，然后执行 implementation-plan.md 的第 N 步。在我验证测试之前，不要开始下一步。”

### 【第三步】执行 (Execute) - “AI 开始编码”
  - AI 接收到指令后，会开始生成或修改代码。你的角色是观察和等待。
  - 开启另外一个工具或者窗口来进行代码review。

### 【第四步】验证 (Validate) - “你扮演质检员”
  - 亲自确认 AI 的工作成果。按照implementation-plan.md 中为该步骤定义的测试方法进行验证。
  - 用 AI 审查 AI 的代码：这是一个非常聪明的技巧。你可以另开一个聊天窗口，让另一个 AI 模型来审查刚才生成的代码变更。指令可以是：“请审查这段代码的质量、可读性以及是否存在潜在问题。”这相当于给你配备了一个 24 小时待命的 QA 工程师。

### 【第五步】记录 (Document) - “更新记忆银行”
  - 测试通过后，立即指令 AI 更新项目文档，这是保证 memory-bank 始终“鲜活”的关键。
  - 指令：“验证通过。请现在更新 progress.md 和 architecture.md。”
    - AI 会在 progress.md 中记录已完成的步骤，并在 architecture.md 中记录新的文件结构或设计见解。

### 【第六步】提交 (Commit) - “刻下历史年轮”
  - 将这个稳定、已验证的版本提交到 Git。这是为你提供坚实的“后悔药”，万一后续步骤出错，可以随时通过 git reset 回到这个安全的状态。
  - 它的结构非常简单：<类型>(<范围>): <描述>
     - 类型 （Type） - 这次提交是什么性质的？这是最重要的部分，它让我们可以快速了解这次变更的目的。常用的类型有：
         - feat： 新功能 （feature）。比如，你增加了一个按钮、一个新页面。
         - fix： 修复 Bug。比如，你修复了一个导致计时器不准的问题。
         - docs： 文档变更。比如，你修改了 README 文件或注释。
         - style： 代码风格调整。比如，修改了缩进、格式，不影响代码逻辑。
         - refactor： 代码重构。在不改变功能的前提下，优化代码结构。
         - test： 增加或修改测试。
         - chore： 构建过程或辅助工具的变动。比如，更新了依赖库。
       - 范围 （Scope） -  这次提交影响了哪个部分？用于说明本次 commit 影响的范围，比如 (api)， (ui)， (timer) 等。
       - 描述 （Description） - 你具体做了什么？
         - 用言简意赅的动词开头，祈使句（比如“增加”而不是“增加了”）。
         - 清晰地描述这次提交做了什么。
         - 通常首字母不用大写，末尾不加句号。
       举几个例子：
       - 糟糕的 Commit：commit 或 update
       - 好的 Commit：
         - feat (api): add start and stop buttons for step 2
         - fix (ui): timer does not reset correctly for step 1
         - docs(timer): update implementation plan for step 3
         - refactor (api): separate timer logic into timer.js for step 4
   - 卓越实践 (100分)
     - 书写“架构师级别”的 Commit Message：亲手书写符合“约定式提交 (Conventional Commits)”规范的 message，例如 feat: add user login functionality。这不仅仅是保存，更是在“讲述项目的故事”，赋予操作以“意义”。

### 【第七步】净化与重复 (Reset & Repeat) - “开启新篇章”
     - 严格遵守“主动净化上下文 (Proactive Context Hygiene)”原则。
     - 在 Cursor 中开启一个全新的聊天会话（Cmd + N），然后再重复第二拍的“指令”环节，开始下一个步骤。
     - 理解“净化”的必要性：这能确保 AI 不会被上一步的讨论、失败的尝试或缓存信息所“污染”。每一次，它都是在一个“干净”的思维环境中，仅基于 memory-bank 里的权威事实来开始新的工作，这能极大地提升输出的准确性。